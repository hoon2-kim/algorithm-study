function solution(arr1, arr2) {
    let answer = [];
    let n = arr1.length;
    let m = arr2.length;
    let a1 = 0; // 배열 a의 포인터
    let a2 = 0; // 배열 b의 포인터

    while (a1 < n && a2 < m) {
        if (arr1[a1] <= arr2[a2]) {
            answer.push(arr1[a1]);
            a1++;
        } else {
            answer.push(arr2[a2]);
            a2++;
        }
    }

    // 배열에 남은 부분 넣기
    while (a1 < n) {
        answer.push(arr1[a1]);
        a1++;
    }
    while (a2 < m) {
        answer.push(arr2[a2]);
        a2++;
    }

    return answer;
}

let a = [1, 3, 5];
let b = [2, 3, 6, 7, 9];
console.log(solution(a, b));

// 참고
// 1. 투 포인터 알고리즘
// 사용 상황:
// 두 배열 또는 두 리스트를 비교하거나 병합할 때.
// 두 포인터가 각자 독립적으로 움직이며 특정 조건을 만족하는 값을 찾는 경우.
// 정렬된 배열이나 리스트에서 특정 합이나 차를 찾는 경우.
// 문제 유형:
// 두 정렬된 배열 병합: 두 개의 정렬된 배열을 하나의 정렬된 배열로 병합하는 문제.
// 두 배열에서 공통 원소 찾기: 두 개의 정렬된 배열에서 공통으로 나타나는 원소를 찾는 문제.
// 특정 합을 찾는 문제: 예를 들어, 주어진 배열에서 두 수의 합이 특정 값이 되는 두 숫자를 찾는 문제.
// 연속된 쌍 찾기: 배열에서 두 수의 합이 특정 값을 만족하는지 확인하는 문제.
// 예시 문제:
// 정렬된 두 배열 병합: 두 개의 정렬된 배열이 주어졌을 때, 이들을 병합하여 하나의 정렬된 배열을 만드는 문제.
// 두 배열의 교집합: 정렬된 두 배열이 주어졌을 때, 두 배열의 교집합을 찾는 문제.
// 2. 슬라이딩 윈도우 알고리즘
// 사용 상황:
// 고정된 크기의 윈도우 (구간)를 배열이나 리스트 위에서 이동시키면서 특정 조건을 만족하는 부분합이나 부분 배열을 찾는 경우.
// 부분 배열이나 부분 문자열에서의 최적화 문제.
// 연속된 구간에 대한 최적의 값(최대, 최소 등)을 찾는 경우.
// 문제 유형:
// 고정된 크기의 부분합: 배열에서 길이가 K인 연속된 부분 배열의 합을 구하는 문제.
// 가변 크기의 부분합: 배열에서 특정 조건을 만족하는 부분 배열의 최솟값이나 최댓값을 찾는 문제.
// 부분 문자열 문제: 문자열에서 특정 길이의 연속된 문자의 집합을 찾는 문제.
// 예시 문제:
// 최대 부분합: 주어진 배열에서 길이가 K인 연속된 부분 배열의 최대 합을 찾는 문제.
// 부분 배열의 합이 특정 값을 초과하는 최소 길이 구하기: 배열에서 부분 배열의 합이 주어진 값 이상이 되는 최소 길이를 찾는 문제.
// 3. 구별하는 방법
// 문제에 "두 개의 독립적인 포인터"가 필요한지 판단: 만약 문제에서 두 배열을 병합하거나, 두 포인터를 서로 비교하면서 값을 찾는 것이 필요하다면 투 포인터 알고리즘을 고려합니다.

// "연속된 구간"에서 최적화를 수행해야 하는지 판단: 문제에서 배열의 연속된 부분을 이동하면서 합이나 최대/최소를 구해야 한다면, 슬라이딩 윈도우 알고리즘이 적합합니다.

// 예시를 통한 이해
// 투 포인터 예시: 주어진 배열에서 두 수의 합이 특정 값이 되도록 하는 두 수를 찾는 문제.

// 이 문제에서는 두 포인터를 처음과 끝에 두고 합이 더 크면 끝 포인터를 줄이고, 더 작으면 처음 포인터를 늘리는 식으로 탐색합니다.
// 슬라이딩 윈도우 예시: 배열에서 길이가 K인 연속된 부분 배열의 최대 합을 구하는 문제.

// 이 문제에서는 처음부터 길이 K만큼의 합을 계산한 후, 윈도우를 오른쪽으로 한 칸씩 이동시키면서 최대 합을 갱신합니다.
